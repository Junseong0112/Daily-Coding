function solution(maps) {
    const n = maps.length; // 맵의 행 크기 (가로)
    const m = maps[0].length; // 맵의 열 크기 (세로)
    // const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]] // 상, 하, 좌, 우
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]] // 상, 하, 좌, 우
    
    const queue = [[0, 0, 1]]; // 행, 열, 이동 횟수
    // 시작 위치 방문 처리 
    maps[0][0] = 0; 

    while(queue.length > 0){ // 큐가 빌 때가지 반복
        
        const [x, y, dist] = queue.shift() // 큐의 맨 앞 요소를 꺼내옴 (하나씩 꺼내서 확인 작업)
        // 현재 위치가 도착 지점인지 확인하기
        if (x === n - 1 && y === m - 1){
            return dist // 이동 횟수 반환
        }
        // 네 방향으로 이동 시도
        for(const [dx, dy] of directions){
            // 새로운 행의 위치 계산
            const nx = x + dx;
            // 새로운 열의 위치 계산
            const ny = y + dy;
            // 새로운 위치가 맵의 범위 안에 있으며, 벽이 아니며, 방문하지 않은 경우
            if (nx >= 0 && nx < n && ny >= 0 && ny < m && maps[nx][ny] === 1) {
                // 새로운 위치를 방문 처리하기 위해 0으로 처리
                maps[nx][ny] = 0;
                // 큐에 새로운 위치와 이동 횟수를 추가
                queue.push([nx, ny, dist + 1]);
            }
        }
    }
    
    return -1
}

// 의사코드
// 1.맵의 크기를 행(n), 열(m)로 초기화한다.
// 2.상, 하, 좌, 우 방향을 나타내는 배열을 초기화한다.
// 3.탐색을 위한 큐를 초기화, 시작 위치(0, 0)와 초기 이동 횟수 (1)를 큐에 넣는다.
// 4.시작 위치를 방문 처리(0)한다.
// 5.큐가 비어 있을 때까지 반복한다.
    // 5-1 큐의 맨 앞 요소를 꺼낸다.
    // 5-2 현재 위치가 도착 지점인지 확인한다.
        // 5-2-1 도착 지점이면 현재까지의 이동 횟수를 반환한다.
    // 5-3 네 방향으로 이동을 시도한다.
        // 5-3-1 새로운 위치를 계산
        // 5-3-2 새로운 위치가 맵의 범위 내에 있고, 벽이 아니며, 방문하지 않은 경우:
            // 5-3-2-1 새로운 위치를 방문처리한다.
            // 5-3-2-2 큐에 새로운 위치와 이동 횟수를 추가한다.
// 6.큐가 비었는데도 도착 지점에 도달하지 못한다면 -1를 반환한다.